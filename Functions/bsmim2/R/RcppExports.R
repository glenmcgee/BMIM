# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' MCMC for BSMIM
#' 
#' Returns posterior draws for \eqn{\theta},\eqn{\lambda^{-1}},\eqn{\rho},\eqn{\sigma^2},\eqn{\gamma}, as well as the mean(\eqn{h}) and cov(\eqn{h})
#' Adapted from "bkmrdlm_multi.cpp" in the "regimes" package by Ander Wilson.
#' Note that this implementation with horseshoe2 prior returns posterior draws of \eqn{\rho} as a list of M matrices (unlike main MCMC code, which returns one matrix of M columns)
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param b_lambda hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lambdaB hyperparameter for \eqn{\lambda^{-1}_B}
#' @param a_sig first hyperparameter for \eqn{\sigma^{-2}}
#' @param b_sig second hyperparameter for \eqn{\sigma^{-2}}
#' @param tau02 hyperparameter for tau2; classic horseshoe is 1
#' @param kappa vector of hyperparameters \eqn{\kappa_m} for \eqn{\theta^*_m}
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param horseshoe 0 = no selection, 1 = componentwise horseshoe priors
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @param draw_h 0 = dont draw h, 1 = draw h
#' @param n_inner no. of MCMC iterations to run in the inner loop. n_outer*n_inner iteraction will be run.
#' @param n_outer no. of MCMC iterations to run in the outer loop. n_outer iterations will be saved.
#' @param n_burn no. of MCMC iterations to discard as burn-in
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson).
#' @export
bsmim_mcmc2 <- function(yz, Xlist, b_lambda, b_lambdaB, a_sig, b_sig, tau02, kappa, poly, d, horseshoe, randint, Bmat, draw_h, n_inner, n_outer, n_burn) {
    .Call(`_bsmim2_bsmim_mcmc2`, yz, Xlist, b_lambda, b_lambdaB, a_sig, b_sig, tau02, kappa, poly, d, horseshoe, randint, Bmat, draw_h, n_inner, n_outer, n_burn)
}

#' MCMC for BSMIM with spike and slab prior (inv-uniform slab for rho version)
#' 
#' Returns posterior draws for \eqn{\theta},\eqn{\lambda^{-1}},\eqn{\rho},\eqn{\sigma^2},\eqn{\gamma}, as well as the mean(\eqn{h}) and cov(\eqn{h})
#' Adapted from "bkmrdlm_multi.cpp" in the "regimes" package by Ander Wilson.
#' Note that this implementation with horseshoe2 prior returns posterior draws of \eqn{\rho} as a list of M matrices (unlike main MCMC code, which returns one matrix of M columns)
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param a_lam shape hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lam rate hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lambdaB hyperparameter for \eqn{\lambda^{-1}_B}
#' @param a_sig first hyperparameter for \eqn{\sigma^{-2}}
#' @param b_sig second hyperparameter for \eqn{\sigma^{-2}}
#' @param a_theta lower bound of unif for invunif prior on \eqn{\theta^{*2}_m}
#' @param b_theta upper bound of unif for invunif prior on \eqn{\theta^{*2}_m}
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param horseshoe 0 = no selection, 1 = componentwise horseshoe priors
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @param draw_h 0 = dont draw h, 1 = draw h
#' @param n_inner no. of MCMC iterations to run in the inner loop. n_outer*n_inner iteraction will be run.
#' @param n_outer no. of MCMC iterations to run in the outer loop. n_outer iterations will be saved.
#' @param n_burn no. of MCMC iterations to discard as burn-in
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson).
#' @export
bsmim_spikeslab_mcmc2 <- function(yz, Xlist, a_lam, b_lam, b_lambdaB, a_sig, b_sig, a_theta, b_theta, step_theta, a_pi, b_pi, poly, d, randint, Bmat, draw_h, n_inner, n_outer, n_burn) {
    .Call(`_bsmim2_bsmim_spikeslab_mcmc2`, yz, Xlist, a_lam, b_lam, b_lambdaB, a_sig, b_sig, a_theta, b_theta, step_theta, a_pi, b_pi, poly, d, randint, Bmat, draw_h, n_inner, n_outer, n_burn)
}

#' MCMC for BSMIM with spike and slab prior (inv-uniform slab for rho version)
#' 
#' Returns posterior draws for \eqn{\theta},\eqn{\lambda^{-1}},\eqn{\rho},\eqn{\sigma^2},\eqn{\gamma}, as well as the mean(\eqn{h}) and cov(\eqn{h})
#' Adapted from "bkmrdlm_multi.cpp" in the "regimes" package by Ander Wilson.
#' Note that this implementation with horseshoe2 prior returns posterior draws of \eqn{\rho} as a list of M matrices (unlike main MCMC code, which returns one matrix of M columns)
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param a_lam shape hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lam rate hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lambdaB hyperparameter for \eqn{\lambda^{-1}_B}
#' @param a_sig first hyperparameter for \eqn{\sigma^{-2}}
#' @param b_sig second hyperparameter for \eqn{\sigma^{-2}}
#' @param tau02 hyperparameter for tau2; classic horseshoe is 1
#' @param kappa vector of hyperparameters \eqn{\kappa_m} for \eqn{\theta^*_m}
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param horseshoe 0 = no selection, 1 = componentwise horseshoe priors
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @param draw_h 0 = dont draw h, 1 = draw h
#' @param n_inner no. of MCMC iterations to run in the inner loop. n_outer*n_inner iteraction will be run.
#' @param n_outer no. of MCMC iterations to run in the outer loop. n_outer iterations will be saved.
#' @param n_burn no. of MCMC iterations to discard as burn-in
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson).
#' @export
bsmim_spikeslab_gaussprior_mcmc2 <- function(yz, Xlist, a_lam, b_lam, b_lambdaB, a_sig, b_sig, s_theta, step_theta, a_pi, b_pi, poly, d, randint, Bmat, draw_h, n_inner, n_outer, n_burn) {
    .Call(`_bsmim2_bsmim_spikeslab_gaussprior_mcmc2`, yz, Xlist, a_lam, b_lam, b_lambdaB, a_sig, b_sig, s_theta, step_theta, a_pi, b_pi, poly, d, randint, Bmat, draw_h, n_inner, n_outer, n_burn)
}

#' MCMC for BSMIM with spike and slab prior (inv-uniform slab for rho version)
#' 
#' Returns posterior draws for \eqn{\theta},\eqn{\lambda^{-1}},\eqn{\rho},\eqn{\sigma^2},\eqn{\gamma}, as well as the mean(\eqn{h}) and cov(\eqn{h})
#' Adapted from "bkmrdlm_multi.cpp" in the "regimes" package by Ander Wilson.
#' Note that this implementation with horseshoe2 prior returns posterior draws of \eqn{\rho} as a list of M matrices (unlike main MCMC code, which returns one matrix of M columns)
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param a_lam shape hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lam rate hyperparameter for \eqn{\lambda^{-1}}
#' @param b_lambdaB hyperparameter for \eqn{\lambda^{-1}_B}
#' @param a_sig first hyperparameter for \eqn{\sigma^{-2}}
#' @param b_sig second hyperparameter for \eqn{\sigma^{-2}}
#' @param tau02 hyperparameter for tau2; classic horseshoe is 1
#' @param kappa vector of hyperparameters \eqn{\kappa_m} for \eqn{\theta^*_m}
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param horseshoe 0 = no selection, 1 = componentwise horseshoe priors
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @param draw_h 0 = dont draw h, 1 = draw h
#' @param n_inner no. of MCMC iterations to run in the inner loop. n_outer*n_inner iteraction will be run.
#' @param n_outer no. of MCMC iterations to run in the outer loop. n_outer iterations will be saved.
#' @param n_burn no. of MCMC iterations to discard as burn-in
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson).
#' @export
bsmim_informative_mcmc2 <- function(yz, Xlist, a_lam, b_lam, b_lambdaB, a_sig, b_sig, s_theta, step_theta, a_pi, b_pi, poly, d, randint, Bmat, draw_h, thetaconstraint, a_slabpos, b_slabpos, alphas, a_rho, b_rho, n_inner, n_outer, n_burn) {
    .Call(`_bsmim2_bsmim_informative_mcmc2`, yz, Xlist, a_lam, b_lam, b_lambdaB, a_sig, b_sig, s_theta, step_theta, a_pi, b_pi, poly, d, randint, Bmat, draw_h, thetaconstraint, a_slabpos, b_slabpos, alphas, a_rho, b_rho, n_inner, n_outer, n_burn)
}

#' Predicting hnew for BSMIM by Component
#' 
#' Returns a list containing (points by (sum_m Lm) ) matrices of hmean and hvar
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param thetalist list of (N by L_m) matrices representing X_m
#' @param psilist list of basis matrices
#' @param rho (S by M) matrix of rho_m draws
#' @param gamma list of (S by P_z) matrices with gamma draws
#' @param lambdaInverse S-vector of lambda^{-1} draws
#' @param lambdaBInverse S-vector of lambda^{-1}_B draws
#' @param sigma2 S-vector of sigma^2 draws
#' @param weightslist list of (S by L_m) weight matrices to apply to exposures X_m (basically A theta^*, so that X*theta*=x(Atheta*)) 
#' @param gridpoints (points by M) matrix containing grid of new index levels for each index m
#' @param Xqlist list of L_m-vectors containing exposure quantiles
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson)
#' @export
bsmim_predict_old_cpp2 <- function(yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, Xqlist, poly, d, randint, Bmat) {
    .Call(`_bsmim2_bsmim_predict_old_cpp2`, yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, Xqlist, poly, d, randint, Bmat)
}

#' Predicting hnew for BSMIM by Component
#' 
#' Returns a list containing (points by (sum_m Lm) ) matrices of hmean and hvar
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param thetalist list of (N by L_m) matrices representing X_m
#' @param psilist list of basis matrices
#' @param rho (S by M) matrix of rho_m draws
#' @param gamma list of (S by P_z) matrices with gamma draws
#' @param lambdaInverse S-vector of lambda^{-1} draws
#' @param lambdaBInverse S-vector of lambda^{-1}_B draws
#' @param sigma2 S-vector of sigma^2 draws
#' @param weightslist list of (S by L_m) weight matrices to apply to exposures X_m (basically A theta^*, so that X*theta*=x(Atheta*)) 
#' @param gridpoints (points by M) matrix containing grid of new index levels for each index m
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson)
#' @export
bsmim_predict_cpp2 <- function(yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, poly, d, randint, Bmat) {
    .Call(`_bsmim2_bsmim_predict_cpp2`, yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, poly, d, randint, Bmat)
}

#' Predicting hnew for BSMIM by Component using APPROXIMATE method, computing the conditional mean and variance of hnew given posterior means of everything else
#' 
#' Returns a list containing (points by (sum_m Lm) ) matrices of hmean and hvar
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param thetalist list of (N by L_m) matrices representing X_m
#' @param psilist list of basis matrices
#' @param rho (S by M) matrix of rho_m draws
#' @param gamma list of (S by P_z) matrices with gamma draws
#' @param lambdaInverse S-vector of lambda^{-1} draws
#' @param lambdaBInverse S-vector of lambda^{-1}_B draws
#' @param sigma2 S-vector of sigma^2 draws
#' @param weightslist list of (S by L_m) weight matrices to apply to exposures X_m (basically A theta^*, so that X*theta*=x(Atheta*)) 
#' @param gridpoints (points by M) matrix containing grid of new index levels for each index m
#' @param Xqlist list of L_m-vectors containing exposure quantiles
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @author Glen McGee (adapted from the "regimes" package by Ander Wilson)
#' @export
bsmim_predict_approx_old_cpp2 <- function(yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, Xqlist, poly, d, randint, Bmat) {
    .Call(`_bsmim2_bsmim_predict_approx_old_cpp2`, yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, Xqlist, poly, d, randint, Bmat)
}

#' Predicting hnew for BSMIM by Component using APPROXIMATE method, computing the conditional mean and variance of hnew given posterior means of everything else
#' 
#' Returns a list containing (points by (sum_m Lm) ) matrices of hmean and hvar
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param thetalist list of (N by L_m) matrices representing X_m
#' @param psilist list of basis matrices
#' @param rho (S by M) matrix of rho_m draws
#' @param gamma list of (S by P_z) matrices with gamma draws
#' @param lambdaInverse S-vector of lambda^{-1} draws
#' @param lambdaBInverse S-vector of lambda^{-1}_B draws
#' @param sigma2 S-vector of sigma^2 draws
#' @param weightslist list of (S by L_m) weight matrices to apply to exposures X_m (basically A theta^*, so that X*theta*=x(Atheta*)) 
#' @param gridpoints (points by M) matrix containing grid of new index levels for each index m
#' @param Xqlist list of L_m-vectors containing exposure quantiles
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @author Glen McGee (adapted from the "regimes" package by Ander Wilson)
#' @export
bsmim_predict_approx_cpp2 <- function(yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, poly, d, randint, Bmat) {
    .Call(`_bsmim2_bsmim_predict_approx_cpp2`, yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, poly, d, randint, Bmat)
}

#' Predicting hnew for BSMIM by Index
#' 
#' 
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param thetalist list of (N by L_m) matrices representing X_m
#' @param psilist list of basis matrices
#' @param rho (S by M) matrix of rho_m draws
#' @param gamma list of (S by P_z) matrices with gamma draws
#' @param lambdaInverse S-vector of lambda^{-1} draws
#' @param lambdaBInverse S-vector of lambda^{-1}_B draws
#' @param sigma2 S-vector of sigma^2 draws
#' @param weightslist list of (S by L_m) weight matrices to apply to exposures X_m (basically A theta^*, so that X*theta*=x(Atheta*)) 
#' @param gridpoints (points by M) matrix containing grid of new index levels for each index m
#' @param Xmedianlist list of L_m-vectors containing exposure medians   
#' @param Eq M-vector of index quantiles
#' @param crossM index to set cross section
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson)
#' @export
bsmim_predict_indexwise_cpp2 <- function(yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpoints, Xmedianlist, Eq, crossM, poly, d, randint, Bmat) {
    .Call(`_bsmim2_bsmim_predict_indexwise_cpp2`, yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpoints, Xmedianlist, Eq, crossM, poly, d, randint, Bmat)
}

#' Generic function for predicting hnew for BSMIM given new exposure levels X
#' 
#' Returns a matrix containing hmean and hvar
#' 
#' @param yz matrix [Y,Z], Z does not include a vector of 1s (i.e. no intercept)
#' @param Xlist list of (N by L_m) matrices representing X_m
#' @param thetalist list of (N by L_m) matrices representing X_m
#' @param psilist list of basis matrices
#' @param rho (S by M) matrix of rho_m draws
#' @param gamma list of (S by P_z) matrices with gamma draws
#' @param lambdaInverse S-vector of lambda^{-1} draws
#' @param lambdaBInverse S-vector of lambda^{-1}_B draws
#' @param sigma2 S-vector of sigma^2 draws
#' @param weightslist list of (S by L_m) weight matrices to apply to exposures X_m (basically A theta^*, so that X*theta*=x(Atheta*)) 
#' @param gridpoints (points by M) matrix containing grid of new index levels for each index m
#' @param poly 0 = gaussian kernel, 1 = polynomial kernel
#' @param d degree of polynomial kernel
#' @param randint 0 = no random intercepts, 1 = random intercepts model
#' @param Bmat N xN block diagonal matrix indicating cluster membership for random intercepts model
#' @author Glen McGee and Ander Wilson (adapted from the "regimes" package by Ander Wilson)
#' @export
bsmim_predict_X_cpp2 <- function(yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, poly, d, randint, Bmat) {
    .Call(`_bsmim2_bsmim_predict_X_cpp2`, yz, Xlist, thetalist, psilist, rho, gamma, lambdaInverse, lambdaBInverse, sigma2, weightslist, gridpointslist, poly, d, randint, Bmat)
}

